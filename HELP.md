## Вступление

На микросервисы внутри компании мы перешли уже давно, а сейчас так и вовсе вплотную работаем с сервис мешом на базе
Истио по разными инсталяциями будь то кубер или опеншифт. Конечно мир микросервисов полон своих проблем и подводных
камней и это безусловно не панацея. Одна из проблем это прорва ресурсов, которые требуется для зоопарка микросервисов,
поэтому вопросы оптимизации возникают постоянно. И вот в результате мы дошли до Proxyless и стали его щупать.
Сегодня мы как раз и разберем насколько сложно превратить «обычный» сервис подключенный к истио в проксилесс сервис
подключенный к истио.

#### Слайд с требованиями для XSD клиента

Начнем с того что нам понадобится для сотворения чуда. На самом то деле не так уж и много. Нужен сам gRPC клиент,
но есть нюанс что поддержка XDS появилась лишь относительно недавно поэтому версия как минимум должна быть 1.39+,
а если мы хотим что бы хотя бы часть функционала сервис меша была доступно, то берем максимально свежую версию.
В последних версиях парням удалось добиться работы ретраев, добавить, поддержку провайдеров сертификатов и rbac.

#### Слайд с bootstrap.json

Чтобы заработал механизм нам необходим бутстрап файл, в котором будет информация про подключение к xds серверу и
самоидентификацией. XDS сервер поможет нам с сервис дискавери, роутингом и трафик менеджментом.
Для того чтобы он подхватился клиентом надо обязательно указать env GRPC_XDS_BOOTSTRAP значением должен быть путь до
файла с бутстрап конфигом. Из чего состоит бутстрап и что там обязательно.

#### Слайд с кодом клиента

Теперь дело за малым, опишем наши авторизационные данные и сделаем фолбэк на авторизацию по незащищенному протоколу.
Что это означает? А то что мы попробуем использовать для авторизации секцию из бутстрап файла и если нифига не выйдет,
то откроем дверь с ноги.
Что бы вся эта история с XDS заработала нам обязательно нужно указать протокол xds:\\\ при обращении к хосту поставщика
и в таком случае уже будет иницирован коннект к xds серверу за получением всех необходимых данных для совершения
запроса.
Как показала практика при создании вашего сервиса для отладки лучше сразу включить логирование XDS клиента
в режиме TRACE или DEBUG так как только так вы сможете понять уходит ли ваш запрос туда куда нужно.

#### Слайд с кодом сервера

Перейдем к бэку. В целом на стороне сервера история начинается так же как и с клиентом.
Требуется все тот же бутстрап файл и креды для подключения. Тут повторятся не будем так как они похожи отличаются
только тем что в одном случае используется XdsChannelCredentials, а в другом XdsServerCredentials.
Для инициализации сервера используем специальный класс XdsServerBuilder, на вход передадим порт и наши креды
для авторизации. В среде кубера или шифта и подобном при запуске нашего сервиса мы бы столкнулись с тем что он
не запускается и жалуется что не может захендлить листенера по порту на котором у нас поднимается gRPC сервер,
очень конечно прозрачная ситуация дальше ехать не куда. Дело в том что для корректной работы ему обязательно
потребуется Service и только при его наличии xds сервер начинает нормально дискаверить свой собственную апликуху.
В целом я бы сказал что на это все если я хотел сделать еще один бесполезный сервис, НО мы же тут не для этого поэтому
не ограничимся азами

#### Слайд с административными сервисами

Отладка всей этой истории то еще удовольствие так как многие вещи спрятаны под капотом и добираться то них не просто
особенно учитывая, то факт что локально без сервера xds истио не особо от дебажишься и нужно либо что-то подобное
разворачивать либо плодить тунели поднимать агенты и вообще заниматься удаленной отладкой что тоже не всегда доступно.
Что же мы можем сделать что бы хоть немного облегчить себе жизнь?
Во-первых это сразу сделать logging.level.io.grpc.xds.XdsLogger=TRACE, поверьте за эту строчку вы не раз скажете себе
спасибо (конечно при эксплуатации ни о каком трейсе речи быть не может поэтому просто вынесите это в настройки)
А во вторых есть служебные сервисы которые подключаются таким образом .addServices(AdminInterface.getStandardServices())
Эти сервисы публикуют gRPC апи которое вам поможет снять XDS дамп (только серверную его часть)
с помощью запроса envoy.service.status.v3.ClientStatusDiscoveryService/FetchClientStatus
и информацию по пулу коннектов и открытых каналах с помощью сервиса grpc.channelz.v1.Channelz/GetTopChannels
(есть еще парочку вспомогательных методов)
Так же рекомендую подключать (тоже по флажку) сервис
.addService(ProtoReflectionService.newInstance()) что позволит вам использовать без прото файла такие тулзы как grpcurl

#### Слайд с интерсепторами

Отдельно хочу остановится на мониторинге, логировании и трейсинге grpc сервисов. Недостаточно сделать просто полезный  
сервис что бы он стал похож на энтерпрайз, надо сделать так что бы его можно было поддерживать и сопровождать,
а для этого нам надо знать в каком состоянии наш сервис и какие-то инструменты для работы с инцидентами.
У gRPC есть отличная вещь такая как интерсепторы. По факту это прикладные прокси классы которые могут добавить какую-то
логику к каждому входящему или исходящему запросу. Я добавил к своему сервису 3 интерсептора
TracingServerInterceptor (библиотека io.opentracing.contrib:opentracing-grpc) - Для того что бы отбрасывать трейсы моих
запросов в Ягеря
MonitoringServerInterceptor (библиотека me.dinowernli:java-grpc-prometheus) - для того что бы отбрасывать метрики
запросов в прометей а из него в графану
LoggingInterceptor (сам написал!!!) - Логи что бы добавить логирование запросов (интеграционный журнал)

В таком виде наш сервис не только выполняет нужный нам бизнесовый функционал но мы его еще можем попытаться и
посопровождать)

## Демо тайм

#### Слайд с архитектурой демо стенда (сервисы, неймспейсы, стрелочки)

Вот сейчас мы с вами и попробуем всю эту страшную теорию на практике. Хотим мы значит сделать сервис который будет нас
приветствовать, да не простой сервис, а proxyless, да пусть он еще и может делать запросы к обычному сервису который уже
к истио подключен по-старинке.   
Показываю код демо приложения, пробегаюсь поочередно по классам клиента, сервера, простого приложения, чуть делаю акцент
на разнице между xds сервисом и обычным. Все написано с помощью спринг бута и вообще было просто и быстро все как мы
любим (но это не точно). Давайте задеплоим это все в кубер.

#### Дальше два пути:

#### Сценарий 1:

предподготовленного нет ничего и я просто делаю куб эплай всех трех компонентов по ходу рассказывая какой компонент
куда деплою и какую роль он будет играть. После деплоя подключаюсь к клиенту и делаю с него запросы на новый и
старый сервисы и показываю что работает. Это самый короткий сценарий.

#### Сценарий 2:

В кластере уже загружен сервис который подключен по классике к истио это типа легаси, можно сделать какой нибудь
интерфейс где отображаются текущие доступные сервисы и кнопку "сделать запрос к сервису" там будет пока наш
простой сервис 3 [deploy/srv3/all.yaml](deploy/srv3/all.yaml), мы покажем что все работает и мы хотим добавить
новые супер пупер проксилес сервисы к нашей истории, заливаем сервис 1 [deploy/srv1/all.yaml](deploy/srv1/all.yaml) и
клиент и показываем вот смотрите оно как бы и по старинке доступно и по новомодному из проксилесс клиента.
Следующим этапом показываем что мы еще можем в версии и балансировку трафика по версиям и деплоим
сервис 2 [deploy/srv2/all.yaml](deploy/srv2/all.yaml) с DR и VS. 
Делаем 10 запросов и показываем примерное распределение, должно соответствовать нашим настройкам.

#### Мониторинг, логи и трейсы
После демо показываем как можно работать с метриками в графане, по сути просто показываем вот как это должно выглядеть 
и то что дашборды вы найдете в материалах к докладу. 
Показывам ягеря и как можно смотреть трейсы. 
В конце говорю про логи что для них обычно можно использовать что-то типа флюентбита и отправку в какую нибудь елку.
По демо части все. 

### Итоги
Говорим про исследования гугла на тему выгоды использования, про ресурсы и латенси, про текущее состояние и известные 
планы на будущее и про остальное что придумает Макс
   

### Интерактив
1 Нет бутстрапа или GRPC_XDS_BOOTSTRAP
2 Кривой бутстрап
3 Нет xds сервера
4 нет протокола xds
5 нет сервиса
6 нет поддержки всего функционала
